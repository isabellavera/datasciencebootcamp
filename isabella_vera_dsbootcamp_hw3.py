# -*- coding: utf-8 -*-
"""Isabella_Vera_DSBootcamp_HW3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14YoT-3xjlD5rrKIjfvXeRD1TW7M54d5Z
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# set up notebook to show all outputs in a cell, not only last one


from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"

url = 'https://data.cityofnewyork.us/api/views/6fi9-q3ta/rows.csv?accessType=DOWNLOAD'
df = pd.read_csv(url,sep=',')

df.head()

df.shape

df.columns
df.dtypes

df.info()

df['hour_beginning'] = pd.to_datetime(df['hour_beginning'])
df.info()
df['hour_beginning'].head(5)

df['hour'] = df['hour_beginning'].dt.hour
df['month'] = df['hour_beginning'].dt.month
df['date'] = df['hour_beginning'].dt.date
df['day_name'] = df['hour_beginning'].dt.day_name()

df.head()

df.isnull().sum()

df.loc[df['events'].notnull()]

df.loc[df.temperature.isnull()]   #Return values where temp is not null

# get beginning and end of date range
min_dt = df.hour_beginning.min()
max_dt = df.hour_beginning.max()
print(min_dt)
print(max_dt)

expected_range = pd.date_range(start = min_dt, end = max_dt, freq='H' )
expected_range

# then identify the missing hours
missing_hours = expected_range.difference(df['hour_beginning'])
print(missing_hours)

df = df.sort_values(by='hour_beginning') #Arranging data in chronological order first and then proceeding to forward/back fill
df.head()

df.reset_index(drop=True, inplace=True)  #drop=True discards the current index, inplace=True applies changes to the df
df.head()

df['temperature'] = df['temperature'].fillna(method="ffill")
df['precipitation'] = df['precipitation'].fillna(method="ffill")
df['weather_summary'] = df['weather_summary'].fillna(method="ffill")

df.isnull().sum()

df.describe()

df.weather_summary.value_counts()

df.groupby('weather_summary')['precipitation'].describe()   #It computes summary statistics for the 'precipitation' values within each group.

df.groupby('month')['temperature'].describe()

sns.pairplot(df,
             vars=['Pedestrians', 'temperature', 'precipitation', 'hour', 'month'],
             plot_kws={'alpha':0.5, 'size': 0.1})

# Plotting a histogram of pedestrian counts
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='Pedestrians')
plt.title('Histogram of Pedestrians on Brooklyn Bridge')
plt.xlabel('Pedestrian Count')
plt.ylabel('Frequency')
plt.show()

# Creating a correlation matrix
correlation_matrix = df[['Pedestrians', 'temperature', 'precipitation']].corr()

# Plotting the correlation matrix as a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Pedestrians, Temperature, and Precipitation')
plt.tight_layout()
plt.show()

"""HW POINT 1: Filter the data to include only weekdays (Monday to Friday) and plot a line graph showing the pedestrian counts for each day of the week."""

# Filter only weekdays
df[df['hour_beginning'].dt.dayofweek < 6]
df_weekdays['day_name'].unique()

weekday_counts = (
    df_weekdays.groupby('day_name')['Pedestrians']
    .mean()
    .reindex(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'])
)

# Plot
plt.figure(figsize=(8,5))
plt.plot(weekday_counts.index, weekday_counts.values, marker='o', linestyle='-', color='magenta')

plt.title('Average Pedestrian Count by Weekday', fontsize=14)
plt.xlabel('Day of the Week', fontsize=10)
plt.ylabel('Average Pedestrian Count', fontsize=10)
plt.grid(True)
plt.show()

"""Track pedestrian counts on the Brooklyn Bridge for the year 2019

Analyze how different weather conditions influence pedestrian activity in that year.

Sort the pedestrian count data by weather summary to identify any correlations( with a correlation matrix) between weather patterns and pedestrian counts for the selected year.
"""

df_2019 = df[df['hour_beginning'].dt.year == 2019].copy()

print("Rows in 2019:", df_2019.shape[0])
print("Date range:", df_2019['hour_beginning'].min(), "→", df_2019['hour_beginning'].max())

# Daily total pedestrians
daily_2019 = (
    df_2019
    .set_index('hour_beginning')
    .resample('D')['Pedestrians']
    .sum()
    .to_frame('Pedestrians')
    .reset_index()
)

# Merge back daily average weather (mean temp & total precip per day)
daily_weather = (
    df_2019
    .set_index('hour_beginning')
    .resample('D')
    .agg({
        'temperature': 'mean',
        'precipitation': 'sum'
    })
    .reset_index()
)

daily_2019 = daily_2019.merge(daily_weather, on='hour_beginning', how='left')
daily_2019.rename(columns={'hour_beginning':'date'}, inplace=True)

daily_2019.head()

plt.figure(figsize=(12,4))
plt.plot(daily_2019['date'], daily_2019['Pedestrians'])
plt.title('Brooklyn Bridge Pedestrian Activity — Daily Totals (2019)')
plt.xlabel('Date')
plt.ylabel('Pedestrians (Daily Total)')
plt.tight_layout()
plt.show()

# Most frequent weather_summary per day
mode_weather = (
    df_2019
    .assign(date=df_2019['hour_beginning'].dt.date)
    .groupby(['date', 'weather_summary'])
    .size()
    .reset_index(name='n')
    .sort_values(['date','n'], ascending=[True, False])
    .drop_duplicates('date')[['date','weather_summary']]
)

daily_2019_w = daily_2019.copy()
daily_2019_w['date'] = daily_2019_w['date'].dt.date
daily_2019_w = daily_2019_w.merge(mode_weather, on='date', how='left')

# Average daily pedestrians by the day’s dominant weather
by_weather_daily = (
    daily_2019_w
    .groupby('weather_summary', dropna=False)['Pedestrians']
    .agg(['count','mean','sum'])
    .sort_values('mean', ascending=False)
)
print(by_weather_daily)

# Use daily_2019_w if you want a dominant daily weather; otherwise use daily_2019 (numeric only)
corr_df_daily = daily_2019_w[['Pedestrians','temperature','precipitation','weather_summary']].copy()

plt.figure(figsize=(10,8))
plt.imshow(C, aspect='auto', interpolation='nearest')
plt.colorbar(label='Correlation')
plt.xticks(range(len(C.columns)), C.columns, rotation=90)
plt.yticks(range(len(C.index)), C.index)
plt.title('Correlation Matrix (2019)')
plt.tight_layout()
plt.show()

sorted_rows = df_2019.sort_values(['weather_summary','Pedestrians'], ascending=[True, False])
sorted_rows[['hour_beginning','weather_summary','Pedestrians','temperature','precipitation']].head(20)

def categorize_time_of_day(hour):
    if 5 <= hour < 12:
        return 'Morning'
    elif 12 <= hour < 17:
        return 'Afternoon'
    elif 17 <= hour < 21:
        return 'Evening'
    else:
        return 'Night'

df['hour_beginning'] = pd.to_datetime(df['hour_beginning'])
df['hour'] = df['hour_beginning'].dt.hour
df['time_of_day'] = df['hour'].apply(categorize_time_of_day)

activity_by_time = (
    df.groupby('time_of_day')['Pedestrians']
    .mean()
    .reindex(['Morning', 'Afternoon', 'Evening', 'Night'])
)

print(activity_by_time)

plt.figure(figsize=(8,5))
plt.bar(activity_by_time.index, activity_by_time.values, color=['#7ec8e3','#4aa96c','#f4a261','#2a9d8f'])
plt.title('Average Pedestrian Activity by Time of Day')
plt.xlabel('Time of Day')
plt.ylabel('Average Pedestrian Count')
plt.show()

combined = df.groupby(['time_of_day', 'weather_summary'])['Pedestrians'].mean().unstack()
print(combined)

plt.figure(figsize=(10,6))
sns.heatmap(combined, cmap='YlGnBu', annot=True, fmt='.0f')
plt.title('Average Pedestrian Count by Time of Day and Weather')
plt.xlabel('Weather')
plt.ylabel('Time of Day')
plt.show()