# -*- coding: utf-8 -*-
"""DS_BootcampProject_

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XiaPVAf76o2xVy104goJOZHOy76kTu-
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Upload and Load Dataset in Google Colab
from google.colab import files
import io
uploaded = files.upload()  # Upload your CSV file
filename = next(iter(uploaded))
# Load with encoding='latin1' to avoid UnicodeDecodeError
df = pd.read_csv(io.BytesIO(uploaded[filename]), encoding='latin1')

# Preview Dataset and Check Columns
print("First 5 rows:")
print(df.head())
print("\nDataset Shape (rows, columns):")
print(df.shape)
print("\n Column Names:")
print(df.columns.tolist())
print("\n Data Info:")
print(df.info())

# Convert date columns to date time because most of them are as an object
df['sampling_date'] = pd.to_datetime(df['sampling_date'], errors='coerce')
df['date'] = pd.to_datetime(df['date'], errors='coerce')

# Check if the date of sampling and date are the same values to see if they are duplicated
(df['sampling_date'] == df['date']).all()

# Clean up the null values
# Check for missing values
print("\n Missing Values in Each Column:")
print(df.isnull().sum())

df.isnull().mean() * 100

#Replace missing values for so2, no2, rspm, spm features with the mean
df['so2'] = df['so2'].fillna(df['so2'].mean())
df['no2'] = df['no2'].fillna(df['no2'].mean())
df['rspm'] = df['rspm'].fillna(df['rspm'].mean())
df['spm'] = df['spm'].fillna(df['spm'].mean())

#for non numerical values we will use the mode, for agency, location and the location of the monitoring station
df['agency'].fillna('Unknown', inplace=True)
df['location_monitoring_station'].fillna('Unknown', inplace=True)
df['location'].fillna('Unknown', inplace=True)

df.isnull().mean() * 100

#check the data description
print("\n Data Info:")
df.describe()

#check time coverage
print("Date range:", df['sampling_date'].min(), "to", df['sampling_date'].max())
df['Year'] = df['sampling_date'].dt.year
df['Month'] = df['sampling_date'].dt.month

#filtering the data so we just have the data from the last 10 years
df_last_10_years = df[(df['sampling_date'].dt.year>= 2005) & (df['sampling_date'].dt.year <= 2015)].copy()
print(df_last_10_years['sampling_date'].min(), df_last_10_years['sampling_date'].max())

# now checking which are the cities with the most polltants on this range, so first define which are the pollutants
pollutants= ['so2','no2','rspm','spm']

city_max= df_last_10_years.groupby('location')[pollutants].max().reset_index()

city_max.head()

#find which has the most for each
for col in pollutants:
  max_city = city_max.loc[city_max[col].idxmax()]
  print(f"Highest recorded {col}: {max_city['location']}({max_city[col]:.2f})")
  max_city.head()

state_means_all = df_last_10_years.groupby('state')[pollutants].mean(numeric_only=True)

# Create a new column for the overall mean pollution
state_means_all['overall_mean'] = state_means_all.mean(axis=1)

# Get the 5 states with the highest overall mean
top_5_states_overall = state_means_all['overall_mean'].nlargest(5).index

# Print them for verification
print("Top 5 states with highest overall average pollution (2005–2015):")
print(state_means_all.loc[top_5_states_overall].sort_values('overall_mean', ascending=False))

# Explore differences in pollution levels between states and cities
df_last_10_years['YearMonth'] = df_last_10_years['sampling_date'].dt.to_period('M')

for col in pollutants:

    mean_values = df_last_10_years.groupby('state')[col].mean(numeric_only=True)
    top_5_states = mean_values.dropna().nlargest(5).index

   # keep only those states, convert YearMonth to timestamp, and aggregate by month
    df_top = (
        df_last_10_years[df_last_10_years['state'].isin(top_5_states)]
        .assign(YearMonth=lambda d: d['YearMonth'].dt.to_timestamp())
        .groupby(['state','YearMonth'], as_index=False)[col].mean()
    )

  # plot
    plt.figure(figsize=(14,7))
    sns.lineplot(
        data=df_top, x='YearMonth', y=col, hue='state', marker='o',
        hue_order=list(top_5_states)  # keep legend order consistent
    )
    plt.title(f'Top 5 States by Mean {col.upper()} (Monthly Avg, 2005–2015)')
    plt.xlabel('Date')
    plt.ylabel(f'{col.upper()} (µg/m³)')
    plt.legend(title='State', bbox_to_anchor=(1.02, 1), loc='upper left')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

#Looking at the locations
print(df['location'].unique())

#Finding out how many different locations there are
df['location'].unique().size

#Looking at the states
print(df['state'].unique())
df['state'].unique().size

#Average SO2 level of pollution for each state
mean_so2_state = df.groupby('state')['so2'].mean()
top_10_so2_state = mean_so2_state.nlargest(10).index.tolist()
top_10_so2_state

#Average SO2 level of pollution for each state
mean_no2_state = df.groupby('state')['no2'].mean()
top_10_no2_state = mean_no2_state.nlargest(10).index.tolist()
top_10_no2_state

# Convert the 'date' column to datetime, coercing errors
df['date'] = pd.to_datetime(df['date'], errors='coerce')

# Extract the year from the 'date' column
df['Year'] = df['date'].dt.year

# Display the first few rows with the new 'Year' column
display(df.head())

#Average pollutants across the years
mean_so2_date = df.groupby('Year')['so2'].mean()
mean_no2_date = df.groupby('Year')['no2'].mean()
mean_rspm_date = df.groupby('Year')['rspm'].mean()
mean_spm_date = df.groupby('Year')['spm'].mean()

#Creating one data frame
mean_pollutant_date = pd.DataFrame({
    'Year': mean_so2_date.index,
    'so2': mean_so2_date.values,
    'no2': mean_no2_date.values,
    'rspm': mean_rspm_date.values,
    'spm': mean_spm_date.values
})

#Turning it into long format
mean_pollutant_date = mean_pollutant_date.melt(
    id_vars='Year',
    var_name='pollutant',
    value_name='mean_value'
)

#Graph of average of each pollutant over the years
plt.figure(figsize=(14, 7))
sns.lineplot(data=mean_pollutant_date, x='Year', y='mean_value', hue='pollutant')
plt.title('Average Pollutant Levels Over Time')
plt.xlabel('Year')
plt.ylabel('Average Concentration', fontsize=12)
plt.legend(title='Pollutant', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""It seems the most variable pollutant is spm"""

#Temporal graph over each month
df['YearMonth'] = df['date'].dt.to_period('M')

# Group by Year-Month (not just Month!)
seasonal_trends_all = df.groupby('YearMonth')[['so2', 'no2', 'rspm', 'spm']].mean().reset_index()

# Convert YearMonth back to datetime for plotting
seasonal_trends_all['YearMonth'] = seasonal_trends_all['YearMonth'].dt.to_timestamp()

# Melt to long format
seasonal_trends_all = seasonal_trends_all.melt(
    id_vars='YearMonth',
    var_name='pollutant',
    value_name='value'
)

# Plot
plt.figure(figsize=(14, 7))
sns.lineplot(data=seasonal_trends_all, x='YearMonth', y='value', hue='pollutant', marker='o')

plt.title('Monthly Average Pollutant Levels Over Time')
plt.xlabel('Date')
plt.ylabel('Average Concentration', fontsize=12)
plt.legend(title='Pollutant', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""rspm wasn't relevant until around 2002

1.   List item
2.   List item


"""

# Extract the month from the 'date' column
df['Month'] = df['date'].dt.month

# Calculate the average pollutant levels for each month
seasonal_trends = df.groupby('Month')[['so2', 'no2', 'rspm', 'spm']].mean().reset_index()

# Display the seasonal trends
display(seasonal_trends)

seasonal_trends = seasonal_trends.melt(
    id_vars='Month',
    var_name='pollutant',
    value_name='mean_value'
)

#Graph of average of each pollutant over the seasons
plt.figure(figsize=(14, 7))
sns.lineplot(data=seasonal_trends, x='Month', y='mean_value', hue='pollutant')
plt.title('Average Pollutant Levels Per Season')
plt.xlabel('Month')
plt.ylabel('Average Concentration', fontsize=12)
plt.legend(title='Pollutant', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""Lowest pollution levels are in the summer

*   List item
*   List item


"""

df.info()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class AQICalculator:
    def __init__(self):
        # Official Indian AQI breakpoints (CPCB - Central Pollution Control Board)
        # Format: Lower breakpoint, Upper breakpoint, Lower AQI, Upper AQI
        self.aqi_breakpoints = {
            'PM2.5': [  # 24-hour PM2.5 (μg/m³)
                (0, 30, 0, 50),
                (30, 60, 51, 100),
                (60, 90, 101, 200),
                (90, 120, 201, 300),
                (120, 250, 301, 400),
                (250, 380, 401, 500)
            ],
            'PM10': [  # 24-hour PM10 (μg/m³) - for RSPM/SPM
                (0, 50, 0, 50),
                (50, 100, 51, 100),
                (100, 250, 101, 200),
                (250, 350, 201, 300),
                (350, 430, 301, 400),
                (430, 500, 401, 500)
            ],
            'SO2': [  # 24-hour SO2 (μg/m³)
                (0, 40, 0, 50),
                (40, 80, 51, 100),
                (80, 380, 101, 200),
                (380, 800, 201, 300),
                (800, 1600, 301, 400),
                (1600, 2000, 401, 500)
            ],
            'NO2': [  # 24-hour NO2 (μg/m³)
                (0, 40, 0, 50),
                (40, 80, 51, 100),
                (80, 180, 101, 200),
                (180, 280, 201, 300),
                (280, 400, 301, 400),
                (400, 500, 401, 500)
            ],
            'CO': [  # 8-hour CO (mg/m³)
                (0, 1.0, 0, 50),
                (1.0, 2.0, 51, 100),
                (2.0, 10, 101, 200),
                (10, 17, 201, 300),
                (17, 34, 301, 400),
                (34, 50, 401, 500)
            ],
            'O3': [  # 8-hour O3 (μg/m³)
                (0, 50, 0, 50),
                (50, 100, 51, 100),
                (100, 168, 101, 200),
                (168, 208, 201, 300),
                (208, 748, 301, 400),
                (748, 1000, 401, 500)
            ]
        }

        # Truncation rules
        self.truncation_rules = {
            'PM2.5': 1,   # 1 decimal place
            'PM10': 0,    # integer
            'SO2': 0,     # integer
            'NO2': 0,     # integer
            'CO': 1,      # 1 decimal place
            'O3': 0       # integer
        }

    def truncate_concentration(self, concentration, pollutant):
        """Apply EPA truncation rules to concentration values"""
        if pd.isna(concentration):
            return concentration

        if pollutant in self.truncation_rules:
            decimal_places = self.truncation_rules[pollutant]
            if decimal_places == 0:
                return int(concentration)
            else:
                return round(concentration, decimal_places)
        return concentration

    def calculate_individual_aqi(self, concentration, pollutant):
        """Calculate AQI using Indian CPCB formula"""

        if pollutant not in self.aqi_breakpoints:
            return np.nan

        if pd.isna(concentration) or concentration < 0:
            return np.nan

        # Applying truncation rules
        Cp = self.truncate_concentration(concentration, pollutant)

        breakpoints = self.aqi_breakpoints[pollutant]

        # Find the appropriate breakpoint range
        for BPLo, BPHi, ILo, IHi in breakpoints:
            if BPLo <= Cp <= BPHi:
                # Indian AQI Formula: I = [(IHi-ILo)/(BPHi-BPLo)] * (Cp-BPLo) + ILo
                if BPHi == BPLo:
                    aqi = ILo
                else:
                    aqi = ((IHi - ILo) / (BPHi - BPLo)) * (Cp - BPLo) + ILo

                return round(aqi)

        # If concentration exceeds highest breakpoint, cap at 500
        if Cp > breakpoints[-1][1]:  # Greater than highest upper breakpoint
            return 500

        return np.nan

    def get_aqi_category(self, aqi):
        """Get AQI category and color (Indian standards)"""
        if pd.isna(aqi):
            return 'Unknown', 'gray'
        elif aqi <= 50:
            return 'Good', 'green'
        elif aqi <= 100:
            return 'Satisfactory', 'lightgreen'
        elif aqi <= 200:
            return 'Moderate', 'yellow'
        elif aqi <= 300:
            return 'Poor', 'orange'
        elif aqi <= 400:
            return 'Very Poor', 'red'
        else:
            return 'Severe', 'maroon'


def calculate_aqi_for_dataset(df, aqi_calc):
    """Calculate AQI for all pollutants in your dataset"""


    # Mapping  to EPA standard pollutants
    pollutant_mapping = {
        'so2': 'SO2',
        'no2': 'NO2',
        'rspm': 'PM10',  # RSPM (Respirable Suspended Particulate Matter) ~ PM10
        'spm': 'PM10',   # SPM can also be treated as PM10
        'pm2_5': 'PM2.5'
    }

    print("Calculating AQI for pollutants...")
    aqi_columns = []

    for col, pollutant in pollutant_mapping.items():
        if col in df.columns:
            print(f"Processing {col} as {pollutant}")

            # Calculate AQI
            aqi_col_name = f'AQI_{col}'
            df[aqi_col_name] = df[col].apply(
                lambda x: aqi_calc.calculate_individual_aqi(x, pollutant)
            )
            aqi_columns.append(aqi_col_name)

            # Show sample values
            sample_data = df[col].dropna().head(3)
            sample_aqi = df[aqi_col_name].dropna().head(3)
            if len(sample_data) > 0:
                print(f"  Sample {col} concentrations: {list(sample_data.values)}")
                print(f"  Sample {col} AQI values: {list(sample_aqi.values)}")

    # To Calculate Overall AQI (maximum of all pollutant AQIs)
    if aqi_columns:
        df['Overall_AQI'] = df[aqi_columns].max(axis=1)
        df['Dominant_Pollutant'] = df[aqi_columns].idxmax(axis=1).str.replace('AQI_', '')
        df['AQI_Category'] = df['Overall_AQI'].apply(
            lambda x: aqi_calc.get_aqi_category(x)[0]
        )
        df['AQI_Color'] = df['Overall_AQI'].apply(
            lambda x: aqi_calc.get_aqi_category(x)[1]
        )

        print(f"\nCalculated AQI for {len(aqi_columns)} pollutants")
        print(f"Overall AQI range: {df['Overall_AQI'].min():.0f} - {df['Overall_AQI'].max():.0f}")
        print(f"Mean AQI: {df['Overall_AQI'].mean():.2f}")

        if 'Dominant_Pollutant' in df.columns:
            dominant_counts = df['Dominant_Pollutant'].value_counts()
            print(f"\nDominant pollutants frequency:")
            for pollutant, count in dominant_counts.items():
                percentage = (count / len(df)) * 100
                print(f"  {pollutant}: {count} times ({percentage:.1f}%)")

        if 'AQI_Category' in df.columns:
            print(f"\nAQI Category Distribution:")
            print(df['AQI_Category'].value_counts())

    return df, aqi_columns





def plot_individual_aqi_timeseries(df, aqi_columns):
    """Plot Individual Pollutant AQIs"""
    plt.figure(figsize=(14, 6))
    colors = ['red', 'blue', 'green', 'orange', 'purple']

    if 'sampling_date' in df.columns:
        if df.index.name != 'sampling_date':
            df_plot = df.set_index('sampling_date')
        else:
            df_plot = df

        for i, col in enumerate(aqi_columns):
            if col in df_plot.columns:
                series = df_plot[col].resample('D').mean()
                series = series.rolling(7, min_periods=1).mean()
                plt.plot(series.index, series.values,
                         label=col.replace("AQI_", "").upper(),
                         color=colors[i % len(colors)], alpha=0.8, linewidth=1.2)

        plt.title("Individual Pollutant AQIs (7-day Rolling Average)", fontsize=14, fontweight="bold")
        plt.ylabel("AQI")
        plt.xlabel("Date")
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()





def plot_aqi_by_state(df):
    """Plot Average AQI by State"""
    if 'Overall_AQI' in df.columns and 'state' in df.columns:
        plt.figure(figsize=(12, 6))

        state_aqi = df.groupby('state')['Overall_AQI'].mean().sort_values(ascending=False)

        colors = ['green' if x <= 50 else 'lightgreen' if x <= 100 else 'yellow' if x <= 200
                  else 'orange' if x <= 300 else 'red' if x <= 400 else 'maroon' for x in state_aqi.values]

        state_aqi.plot(kind='barh', color=colors)
        plt.title("Average AQI by State", fontsize=14, fontweight="bold")
        plt.xlabel("Average AQI")
        plt.ylabel("State")
        plt.grid(True, alpha=0.3, axis='x')
        plt.tight_layout()
        plt.show()


def plot_aqi_by_year(df):
    """Plot Average AQI by Year"""
    if 'Overall_AQI' in df.columns and 'Year' in df.columns:
        plt.figure(figsize=(10, 6))

        yearly_aqi = df.groupby('Year')['Overall_AQI'].mean()

        plt.plot(yearly_aqi.index, yearly_aqi.values, marker='o', linewidth=2, markersize=8)
        plt.title("Average AQI by Year", fontsize=14, fontweight="bold")
        plt.xlabel("Year")
        plt.ylabel("Average AQI")
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()


# Main execution function
def process_air_quality_data(df):
    """Main function to process your air quality data"""

    print("Starting AQI calculation...")
    print(f"Dataset shape: {df.shape}")
    print(f"Date range: {df['sampling_date'].min()} to {df['sampling_date'].max()}")

    # Initialize calculator
    aqi_calc = AQICalculator()

    # Calculate AQI
    df, aqi_columns = calculate_aqi_for_dataset(df, aqi_calc)

    # Create visualizations
    print("\nCreating visualizations...")
    plot_individual_aqi_timeseries(df, aqi_columns)
    plot_aqi_by_state(df)
    plot_aqi_by_year(df)

    return df, aqi_calc

df_with_aqi, calculator = process_air_quality_data(df)